\documentclass[a4paper,12pt]{TahlilDade-report}
\usepackage{TahlilDade-style}

\begin{document}
	
	% ------------------ صفحه عنوان ------------------
	
	\thispagestyle{empty}  % بدون شماره صفحه و بدون هدر/فوتر
	
	\begin{center}
		\textbf{ به نام خدا}\\[1.5cm]
		
		\includegraphics[width=0.28\textwidth]{logo.png}\\[1cm]
		
		\textbf{دانشکده برق ، کامپیوتر و فناوری های پیشرفته}\\[1cm]
		
		\textbf{گروه مهندسی کامپیوتر}\\[1.5cm]
		
		{\Large \textbf{تمرین درس تحلیل داده}}\\[1.5cm]
		
		{\Large \textbf{پیاده سازی یک سیستم پیشنهاد فیلم با روش  \lr{SVD}}}\\[1.5cm]
		
		
		\textbf{نام و نام خانوادگی:} آی‌سودا حاجی‌‌ حسینلو \\[0.6cm]
		\textbf{شماره دانشجویی:} 1404699110 \\[0.6cm]
		\textbf{استاد:} جناب آقای دکتر تاجبخش \\[0.6cm]
		
		
		\vfill
		\today \\[0.3cm]
		\textbf{تمامی حقوق این اثر متعلق به دانشگاه ارومیه می باشد.}
	\end{center}
	
	\newpage
	
	\setcounter{page}{1}    % صفحه چکیده = صفحه ۱
	\pagenumbering{arabic}  % اعداد ۱،۲،۳...
	
	
	%- ---------------------- چکیده ----------------------------
	
	\newsection{چکیده}
	
	در این تمرین، هدف پیاده‌سازی یک سیستم پیشنهاد فیلم بر اساس داده‌های امتیاز کاربران با استفاده از تکنیک تجزیه ماتریس به روش  \lr{SVD (Singular Value Decomposition)}بوده است. داده‌ها شامل امتیازات کاربران به فیلم‌ها از یک \lr{Dataset} آماده از \lr{Kaggle} می‌باشد. تمرین در دو بخش انجام شد: در بخش اول، با استفاده از \lr{SVD}، ماتریس امتیازات بازسازی شده و فیلم‌هایی که کاربران ندیده‌اند، بر اساس پیش‌بینی امتیاز به آن‌ها پیشنهاد شد. در بخش دوم، \%20از داده‌های اصلی حذف شد و همان مراحل روی \%80باقی‌مانده اجرا شد تا دقت سیستم و میزان خطای پیش‌بینی اندازه‌گیری شود. نتایج با استفاده از \lr{RMSE} و \lr{MAE} تحلیل شد و همچنین تأثیر فعالیت کاربران و ژانر فیلم‌ها بر دقت پیش‌بینی بررسی شد. تحلیل‌ها نشان دادند که نرمال‌سازی داده‌ها و افزایش تعداد مؤلفه‌های \lr{SVD} موجب بهبود دقت سیستم پیشنهاد فیلم شده است.
	\newpage
	%-------------------------فهرست مطالب ----------------------
	\tableofcontents
	\newpage
	
	%- ---------------------- مقدمه ----------------------------
	\newsection{مقدمه}
	با رشد سریع حجم داده ها در سیستم های سرگرمی و رسانه های دیجیتال ، ارائه پیشنهادات شخصی سازی شده به کاربران اهمیت زیادی پیدا کرده است.
	سیستم‌های پیشنهاد فیلم یکی از مهم‌ترین کاربردهای این فناوری هستند. هدف اصلی این تمرین، طراحی و پیاده‌سازی یک سیستم توصیه‌گر مبتنی بر امتیاز کاربران با استفاده از تجزیه ماتریس \lr{SVD} است.
	
	\underline{توضیح \lr{SVD} :}
	
	\lr{SVD} یا \lr{Singular Value Decomposition} یک تکنیک ریاضی قدرتمند است که یک ماتریس 
	
	را به سه ماتریس تجزیه می‌کند:
	\lr{$R=UΣV^T$}
	
	\lr{U} ماتریس ویژگی‌های کاربران و \lr{$V^T$} ماتریس ویژگی‌های فیلم‌هاو
	\lr{Σ} ماتریس قطری شامل مقادیر ویژه که اهمیت ویژگی‌ها را نشان می‌دهد.
	با استفاده از \lr{SVD}، می‌توان ماتریس کم‌بعدی از امتیازات کاربران به فیلم‌ها ایجاد کرد که هم کاهش ابعاد انجام می‌دهد و هم نویز داده‌ها را کم می‌کند. سپس این ماتریس بازسازی شده برای پیش‌بینی امتیاز فیلم‌هایی که کاربر ندیده است استفاده می‌شود.
	
	\underline{شرح مراحل تمرین : }
	
	بارگذاری داده‌ها: داده‌های امتیاز کاربران و اطلاعات فیلم‌ها (عنوان و ژانر) از \lr{Dataset} آماده استخراج شد.
	ساخت ماتریس کاربر\lr{-}فیلم:
	
	
	ماتریس امتیازات ساخته شد و مقادیر گمشده با صفر جایگزین شدند.
	
	نرمال‌سازی داده‌ها: 
	
	میانگین امتیاز هر کاربر از امتیازات او کم شد تا سوگیری‌های فردی کاهش یابد.
	
	اجرای \lr{SVD}: 
	
	ماتریس نرمال‌شده با تعداد مؤلفه‌های 
	\lr{k=100} تجزیه و سپس بازسازی شد.
	
	پیشنهاد فیلم: 
	
	بر اساس ماتریس بازسازی شده، فیلم‌هایی که کاربر ندیده بود، با بالاترین امتیاز پیش‌بینی شده به او پیشنهاد شد.
	
	ارزیابی سیستم: 
	
	20\%از داده‌های اصلی حذف شد و مراحل ۲ تا ۵ روی ۸۰\% باقی‌مانده انجام شد. سپس پیش‌بینی‌ها با مقادیر واقعی حذف‌شده مقایسه و \lr{RMSE} و \lr{MAE} محاسبه شد.
	
	تحلیل: 
	تأثیر فعالیت کاربران و ژانر فیلم‌ها بر دقت پیش‌بینی بررسی شد و نمودارهای مربوط به توزیع خطا و \lr{RMSE} بر اساس فعالیت کاربران ترسیم گردید.
	
	\newpage
	
	
	%- ----------------- کد پیاده‌سازی شده و توضیحات آن --------------------
	\newsection{کد پیاده‌سازی شده و توضیحات آن}
	
	ابتدا یک دیتاست از سایت \lr{kaggle} دانلود کردیم \lr{(movie dataset)} که شامل فایل هایی مانند \lr{movie\_metadata.csv} , \lr{ratings\_small.csv} و .... بود :
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (826).png}	\\[0.5cm]
	\end{center} 
	فایل \lr{ratings\_small.csv} حاوی امتیازات کاربران به فیلم ها می باشد و فایل \lr{movie\_metadata.csv} هم اطلاعات توصیفی فیلم‌ها را شامل می شود به عنوان مثال نام و ژانر و.... 
	
	نسخه اولیه کد را به صورت زیر در \lr{pycharm} اجرا کردیم : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (827).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (828).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (829).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (830).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (831).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (832).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (833).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (834).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (835).png}	\\[0.5cm]
	\end{center} 
	
	\underline{توضیح کد : }
	
	۱. وارد کردن کتابخانه‌ها و آماده‌سازی محیط :  کد در ابتدا کتابخانه‌های لازم مانند \lr{pandas}، \lr{numpy}، \lr{scipy}، \lr{sklearn}، \lr{matplotlib} و \lr{seaborn} را برای پردازش داده، انجام محاسبات ریاضی، اجرای \lr{SVD} و ترسیم نمودارها فراخوانی می‌کند.
	همچنین هشدارها غیرفعال شده و پالت گرافیکی تنظیم می‌شود.
	\\[0.25cm]
	۲. بارگذاری و آماده‌سازی داده‌ها : در این بخش فایل‌های \lr{ratings\_small.csv }(حاوی امتیازات کاربران به فیلم‌ها و \lr{movies\_metadata.csv }(اطلاعات فیلم‌ها شامل نام و ژانر) خوانده می‌شوند.
	ستون‌های غیرضروری حذف شده، مقادیر خالی پاک‌سازی می‌شوند و شناسه‌ی فیلم‌ها \lr{(id)} به عدد صحیح تبدیل میشود.
	تابع \lr{extract\_genres} نیز برای استخراج ژانرها از رشته‌های پیچیده استفاده می‌شود و در نهایت داده‌های فیلم‌ها با جدول امتیازات ادغام می‌شوند تا هر امتیاز شامل عنوان و ژانر فیلم هم باشد.
	\newpage
	۳. ساخت ماتریس کاربر-فیلم : کد با استفاده از \lr{pivot\_table،}، یک ماتریس دوبعدی ایجاد می‌کند که سطرها کاربران \lr{(userId)} و ستون‌ها فیلم‌ها \lr{movieIِِِِD} هستند، و مقادیر درون آن امتیازات کاربران به فیلم‌ها است.
	مقادیر خالی با صفر پر می‌شوند تا بتوان از آن در محاسبات ماتریسی استفاده کرد. سپس این ماتریس به صورت فشرده \lr{(car\_matrix)} برای اجرای سریع‌تر \lr{SVD} ذخیره می‌شود.
	\\[0.25cm]
	۴. تجزیه مقدار منفرد : تابع \lr{perform\_svd} با استفاده از \lr{svds} از کتابخانه‌ی \lr{scipy} ماتریس امتیازات را به سه مؤلفه‌ی
	\lr{U}, \lr{Σ} و \lr{Vᵀ} تجزیه می‌کند. سپس با ضرب دوباره‌ی این ماتریس‌ها، نسخه‌ی بازسازی‌شده‌ی ماتریس امتیازات \lr{(R\_pred)} بدست می‌آید که شامل امتیازهای پیش‌بینی‌شده برای تمام کاربران و فیلم‌ها است.
	در اینجا \lr{k=50} یعنی فقط ۵۰ مؤلفه اصلی (بزرگ‌ترین مقادیر منفرد) حفظ می‌شوند تا نویز حذف شود و روابط اصلی میان کاربران و فیلم‌ها باقی بمانند.
	\\[0.25cm]
	۵. تولید پیشنهاد برای کاربران : تابع \lr{recommend\_movies }برای هر کاربر، فیلم‌هایی را که هنوز به آن‌ها امتیاز نداده پیدا می‌کند، سپس از روی ماتریس پیش‌بینی‌شده، بالاترین امتیازها را انتخاب کرده و آن فیلم‌ها را به عنوان پیشنهاد برمی‌گرداند.
	در خروجی تمرین فقط نتایج کاربر ۱ نمایش داده می‌شود (به عنوان نمونه)، اما در واقع مدل برای تمام کاربران پیش‌بینی انجام می‌دهد.
	\\[0.25cm]
	۶. حالت دوم - حذف \%20 داده‌ها و ارزیابی مدل : برای ارزیابی عملکرد مدل، داده‌ها به نسبت \%80  آموزش و \%20  آزمون تقسیم می‌شوند.
	مدل با داده‌های آموزشی \lr{(train)} آموزش می‌بیند و سپس برای داده‌های آزمون \lr{(test)} امتیازها پیش‌بینی می‌شوند.
	خطا بین مقدار واقعی و مقدار پیش‌بینی‌شده با دو معیار مهم محاسبه می‌شود:
	
	\lr{RMSE (Root Mean Square Error)}
	
	\lr{MAE (Mean Absolute Error)}
	
	نمونه‌ای از خطاها در فایل \lr{CSV} ذخیره می‌شود و دوباره برای کاربر ۱ پیشنهادات پس از حذف داده‌ها تولید می‌شود.
	\\[0.25cm]
	۷. تحلیل‌های تصویری و نمودارها : در انتهای کد سه نمودار رسم می‌شود:
	
	توزیع خطاهای پیش‌بینی (برای مشاهده دقت کلی مدل).
	
	\lr{RMSE} بر اساس میزان فعالیت کاربران (تعداد امتیازات داده‌شده).
	
	\lr{RMSE} بر اساس ژانر فیلم‌ها (\lr{Comedy}, \lr{Drama}, \lr{Action} و غیره) برای بررسی عملکرد مدل در دسته‌های مختلف.
	
	نتایج ژانرها در کنسول چاپ می‌شوند تا مشخص شود مدل در کدام نوع فیلم‌ها عملکرد بهتری داشته است.
	
	\newpage
	
	
	%- ----------------- خروجی نسخه اول --------------------
	\newsection{خروجی نسخه اول }
	
	\textbf{نکته : } برای راحتی کار و توضیحات ، در خروجی صرفا کاربر1 را درنظر میگیریم درحالی که برای همه کاربران این پروسه طی شده و فیلم پیشنهاد داده میشود . 
	
	در اجرای نسخه اول (همان کد موجود در بخش قبلی که توضیح دادیم) ، خروجی های زیر را داریم : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (836).png}	\\[0.5cm]
	\end{center} 
	
	بخش اول که شامل اطلاعات کلی داده‌ها میباشد : 
	کل سیستم شامل ۶۷۱ کاربر و ۹۰۶۶ فیلم است.
	
	هر کاربر به چند فیلم امتیاز داده و مجموعاً ۱۰۰۰۰۹ امتیاز ثبت‌شده داریم.
	
	این یعنی ماتریس کاربر-فیلم بسیار پراکنده \lr{(sparse)} است، چون (671×9066) 6 میلیون سلول داریم ولی فقط حدود ۱۰۰هزار مقدار پر شده‌اند.
	\\[0.25cm]
	در بخش دوم ساخت ماتریس و تجزیه \lr{SVD} انجام میشود(مراحل در مقدمه توضیح داده شده است).
	\\[0.25cm]
	در بخش سوم ، پیشنهاد کامل برای کاربر 1 داده میشود : 
	همان طور که قبلا هم اشاره کردیم ، در اینجا فقط پیشنهادهای کاربر 1 چاپ شده است ، اما مدل در واقع برای تمام کاربران پیش‌بینی را انجام میدهد و فقط برای نمونه، کاربر 1 نمایش داده میشود.
	چون داده‌ها نرمال نشده‌اند، امتیازات پیش‌بینی‌شده بسیار پایین (در محدوده‌ی 1.0تا 2.0) هستند.
	مدل فقط ترتیب \lr{(ranking)} را می‌فهمد نه مقدار واقعی - یعنی می‌گوید کدام فیلم بهتر از بقیه است، نه اینکه دقیقاً امتیازش چند است.
	وجود \lr{NaN} در ستون \lr{title} یا \lr{genres} یعنی آن ردیف‌ها مربوط به فیلم‌هایی هستند که در دیتاست \lr{movie}‌ها وجود نداشتند یا \lr{ID}شان در \lr{merge} پیدا نشده است.
	\\[0.25cm]
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (837).png}	\\[0.5cm]
	\end{center} 
	
	در بخش چهارم ، حذف 20\% داده و آموزش مجدد اتفاق می افتد : 
	20\% از داده‌ها برای تست کنار گذاشته شده‌اند.
	
	\lr{SVD} روی 80\% باقی‌مانده اجرا می‌شود.
	
	سپس مقادیر حذف‌شده پیش‌بینی و با مقدار واقعی مقایسه می‌شوند.
	
	معیارها:
	
	\lr{RMSE = 3.1462}
	
	\lr{MAE = 2.9085}
	
	این خطاها بالا هستند، که طبیعی است چون:
	
	مقادیر نرمال‌سازی نشده‌اند.
	
	مدلی که استفاده کردیم ساده‌ است (فقط \lr{SVD} بدون \lr{regularization}).
	
	بعضی کاربران به فیلم‌ها امتیازات کمی دادند.
	\\[0.25cm]
	در بخش پنجم ، نمونه‌ی خطاها را مشاهده میکنیم : 
	مشاهده میکنیم که پیش‌بینی‌ها به‌شدت از واقعیت فاصله دارند.
	برای مثال:
	
	فیلمی که کاربر ۵ داده، مدل حدود 18.1 پیش‌بینی کرده است (خطا = 81.3-)
	
	یعنی مدل توانسته الگوهای کلی را بیاموزد ولی دقت عددی ندارد.
	
	این خطاها در نسخه‌ بعدی (با نرمال‌سازی میانگین کاربر یا تنظیم تعداد مؤلفه‌ها \lr{(k)}) به‌شدت کاهش خواهند یافت.
	\\[0.25cm]
	در بخش ششم ، بعد از حذف 20 درصد دوباره پیشنهادات را میبینیم : 
	دوباره فقط خروجی مربوط به کاربر ۱ نمایش داده میشود.
	تفاوت مقادیر پیش‌بینی نسبت به مرحله‌ی قبل اندک است (به عنوان مثال \lr{Rocky IV }از 26.0 تبدیل شده به 208.0 )
	این یعنی مدل حتی با از دست دادن بخشی از داده‌ها، ساختار کلی توصیه‌ها را حفظ کرده است(هرچند دقت پایین است.)
	\\[0.25cm]
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (838).png}	\\[0.5cm]
	\end{center} 
	در بخش هفتم ، تحلیل خطا براساس ژانر را میبینیم : 
	در این قسمت، خطا برای هر ژانر محاسبه شده است.
	مقادیر نزدیک به هم نشان می‌دهند که مدل برای همه‌ی ژانرها تقریباً عملکرد یکسانی دارد و هیچ ژانری به‌صورت خاص بهتر یا بدتر پیش‌بینی نشده است.
	
	این به خاطر ضعف عمومی مدل پایه‌ای \lr{SVD} بدون نرمال‌سازی است (چون هنوز ویژگی‌های خاص ژانر را به‌خوبی یاد نگرفته است.)
	\\[0.25cm]
	در نهایت علاوه بر نتایجی که دیدیم ، 3 فایل خروجی هم به صورت زیر داریم : 
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (840).png}	\\[0.5cm]
	\end{center} 
	\lr{recommendations\_full.csv} شامل پیش‌بینی‌های کامل برای تمام کاربران (اما     چاپ‌شده فقط برای کاربر 1).
	
	مقدار کم اعداد نشان‌دهنده‌ی نبود نرمال‌سازی است.
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (841).png}	\\[0.5cm]
	\end{center} 
	\lr{recommendations\_test.csv} نتایج پس از حذف 20\% داده، مجدداً برای کاربر ۱ ذخیره شده است.
	
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (842).png}	\\[0.5cm]
	\end{center} 
	\lr{errors\_sample.csv} شامل چند ردیف از مقایسه‌ی واقعی و پیش‌بینی برای تحلیل خطا می باشد.
	
	\newpage
	
	% -------------------- مشکل نسخه اول و رفع آن --------------------
	\newsection{مشکل نسخه اول و رفع آن }
	
	مشکلات نسخه اول و پایه (بدون نرمال‌سازی) به شرح زیر میباشد : 
	
	1.سوگیری کاربران \lr{(User Bias)}:
	
	کاربران سبک‌های مختلف امتیازدهی دارند ، مثلاً یک کاربر همیشه بین ۴ تا ۵ امتیاز می‌دهد و دیگری بین ۲ تا ۳(در این حالت ممکن است سلیقه امتیازدهی کاربر دوم در این رنج باشد ، نه اینکه به فیلم امتیاز کم داده باشد و فیلم را دوست نداشته باشد)
	
	وقتی \lr{SVD} مستقیماً روی ماتریس امتیازات خام اعمال می‌شود، مدل نمی‌تواند تفاوت بین سبک کاربران را در نظر بگیرد.
	
	نتیجه ای که میتوانیم بگیریم : ممکن است پیش بینی ها در مقیاس واقعی اشتباه باشند و مقادیر \lr{RMSE} و \lr{MAE} خیلی بزرگ شوند.
	
	2.مقادیر بازسازی‌شده غیرواقعی:
	
	\lr{SVD}روی داده‌های خام بدون نرمال‌سازی ممکن است مقادیر بازسازی‌شده‌ی ماتریس را حتی منفی یا خیلی کوچک تولید کند ، که برای امتیازدهی درست نیست و معنی ندارد .
	
	این باعث می‌شود مدل فقط بتواند ترتیب نسبی فیلم‌ها را تشخیص دهد و نه مقدار واقعی امتیازها.
	
	3.\lr{RMSE} و \lr{MAE} بالا: 
	
	از آنجایی که مقادیر پیش‌بینی دقیق نیستند، خطاها زیاد میشوند.
	
	در نسخه بهبود یافته اصلاحات زیر را انجام دادیم : 
	
	1.نرمال‌سازی کاربران \lr{(User Mean Normalization):}
	
	قبل از اعمال \lr{SVD}، میانگین امتیاز هر کاربر از داده‌هایش کم می‌شود ، این کار باعث می‌شود که مدل تمرکز بر تفاوت‌ها و الگوهای واقعی کاربران داشته باشد و سبک کلی هر کاربر حذف شود.
	
	2.بازگرداندن میانگین‌ها بعد از \lr{SVD}:
	
	پس از بازسازی ماتریس با \lr{SVD}، میانگین کاربران دوباره اضافه می‌شود،این کار پیش‌بینی‌ها را در محدوده واقعی امتیازها (۱ تا ۵) قرار می‌دهد.
	
	3.مقدار \lr{k} را به 100 افزایش میدهیم تا مدل بتواند جزئیات بیشتری از الگوهای کاربران و فیلم‌ها را یاد بگیرد، بدون اینکه سبک کلی کاربر \lr{(user bias)} باعث اختلال شود.
	
	
	\newpage
	
	% -------------------- نسخه بهبودیافته و توضیح آن --------------------
	\newsection{نسخه بهبودیافته کد و توضیح آن }
	کد بهبودیافته نسبت به نسخه اول به صورت زیر میباشد : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (843).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (844).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (845).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (846).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (847).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (848).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (849).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (850).png}	\\[0.5cm]
	\end{center} 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (851).png}	\\[0.5cm]
	\end{center} 
	
	
	در این بخش تغییراتی که نسبت به نسخه اول کد اعمال کردیم را توضیح میدهیم:
	\newpage
	1.نرمال‌سازی امتیازات کاربران : 
	
	در نسخه اولیه امتیازات کاربران بدون نرمال‌سازی وارد مدل می‌شدند و مدل بیشتر رتبه‌بندی را می‌فهمید نه مقدار واقعی. در نسخه بهبود یافته، میانگین امتیاز هر کاربر از امتیازهای او کم می‌شود و بعد از \lr{SVD} دوباره اضافه می‌شود. این کار باعث می‌شود پیش‌بینی‌ها هم واقعی‌تر و هم قابل تفسیر باشند(کد مربوطه به صورت زیر میباشد)
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (852).png}	\\[0.5cm]
	\end{center} 
	
	بازگرداندن میانگین بعد از \lr{SVD}:
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (853).png}	\\[0.5cm]
	\end{center} 
	
	
	2.افزایش مقدار \lr{k} در \lr{SVD} : 
	
	در نسخه اولیه \lr{k=50 } بود که مدل نمی‌توانست جزئیات کافی از داده‌ها یاد بگیرد ، در نسخه جدید \lr{k=100 } انتخاب شده تا دقت پیش‌بینی بالاتر رود(کد مربوطه به صورت زیر میباشد)
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (854).png}	\\[0.5cm]
	\end{center} 
	
	3.پیش‌بینی داده‌های تست با نرمال‌سازی و \lr{fallback} منطقی : 
	
	نسخه اولیه مقادیر تست گاهی منفی یا خیلی کوچک داشت. در نسخه بهبود یافته، پیش‌بینی برای فیلم‌های ناشناخته برابر0.3 در نظر گرفته شده و میانگین کاربر اضافه می‌شود.(کد مربوطه به صورت زیر میباشد)
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (855).png}	\\[0.5cm]
	\end{center} 
	\newpage
	4.تحلیل \lr{RMSE} بر اساس فعالیت کاربر و ژانر : 
	
	در نسخه اولیه تحلیل‌ها کمتر دقیق بودند و مقادیر پیش‌بینی منفی بود. نسخه جدید با استفاده از نرمال‌سازی و میانگین، \lr{RMSE} بر اساس فعالیت کاربر و ژانر دقیق‌تر شده و داده‌ها قابل مقایسه هستند(کد مربوطه به صورت زیر میباشد)
	
	
	کد مربوط به فعالیت کاربر : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (856).png}	\\[0.5cm]
	\end{center} 
	
	
	کد مربوط به تحلیل ژانر : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (857).png}	\\[0.5cm]
	\end{center}
	
	\newpage
	5.ذخیره نمودار و خروجی‌ها برای مقایسه : 
	
	در نسخه بهبود یافته تمام نمودارها و \lr{CSV} ها ذخیره می‌شوند تا بتوان بین نسخه پایه و نسخه بهبود یافته مقایسه انجام داد(کد مربوطه به صورت زیر میباشد)
	
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (858).png}	\\[1cm]
	\end{center}
	
	به دلیل شباهت بقیه قسمت های کد به کد پایه و اولیه ، دیگر در این قسمت توضیح داده نشده اند ، چرا که در بخش "کد پیاده سازی شده و توضیحات آن" به صورت کامل توضیح داده شده است. 
	\newpage
	
	
	% --------------------مزایای کد بهبودیافته --------------------
	\newsection{مزایای کد بهبودیافته }
	در این بخش به مزیت های کد بهبودیافته اشاره میکنیم : 
	
	1.مقادیر واقعی قابل تفسیر: 
	
	اکنون می‌توان گفت که پیش‌بینی کاربر برای فیلم \lr{X} مثلاً ۴.۳ است، نه فقط مهتر از فیلم \lr{Y} .
	
	2.کاهش خطاها:
	
	\lr{RMSE} و \lr{MAE} کاهش پیدا می‌کنند .
	
	3.رتبه‌بندی دقیق‌تر: 
	
	در این حالت ترتیب و مقدار واقعی را با هم داریم.
	
	5.تحلیل ژانر و فعالیت کاربران بهبود یافته: 
	
	با مقادیر واقعی، می‌توان \lr{RMSE} بر اساس ژانر یا تعداد امتیازات کاربران را دقیق‌تر محاسبه کرد و نمودارها قابل مقایسه می‌شوند.
	
	\newpage
	
	
	% --------------------خروجی کد بهبودیافته --------------------
	\newsection{خروجی کد بهبودیافته }
	
	خروجی نسخه بهبودیافته کد به شرح زیر میباشد : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (860).png}	\\[1cm]
	\end{center}
	
	
	1.آمار اولیه : 
	
	داده‌های پایه همان داده نسخه اولیه است.
	
	671 کاربر، 9066 فیلم و 100009 امتیاز داریم.
	
	تغییری در ابعاد داده‌ها ایجاد نشده است.
	
	
	2.ماتریس و نرمال‌سازی : 
	
	ماتریس کاربر-فیلم ساخته شده و نرمال‌سازی با میانگین امتیاز هر کاربر انجام شده است .
	
	\lr{k} در \lr{SVD} از 50 به 100 افزایش یافته است ،
	این یعنی مدل بهتر می‌تواند ویژگی‌های نهفته \lr{(latent features)} را استخراج کند.
	
	3.پیشنهاد کامل (کاربر 1) : 
	
	تفاوت مهم: مقادیر \lr{predicted\_rating } هم اکنون به‌طور مثبت و نزدیک به 2.0-27.0 هستند.
	
	در نسخه اولیه بدون نرمال‌سازی، خیلی از پیش‌بینی‌ها\lr{(predicted)} منفی یا نزدیک صفر بودند.
	
	ترتیب فیلم‌ها \lr{(ranking)} همچنان حفظ شده، ولی اکنون مقادیر واقعی پیش‌بینی‌ها منطقی‌تر هستند.
	
	وجود \lr{NaN} همچنان دیده می‌شود، اما تعداد پیشنهادهای معتبر کمی بیشتر شده است.
	
	\newpage
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (861).png}	\\[1cm]
	\end{center}
	
	4.ارزیابی : 
	
	\lr{RMSE} و \lr{MAE} کمی افزایش یافته ولی مقادیر پیش‌بینی واقعی شده‌اند.
	
	
	خطاها هنوز بزرگ هستند ولی مقادیر پیش‌بینی در محدوده نرمال‌سازی شده قرار دارند.
	
	
	نکته: مدل هنوز ترجیح می‌دهد ترتیب \lr{(ranking)} را درست کند، نه مقدار  واقعی را .
	
	5.پیشنهاد پس از حذف 20 درصد :
	
	فیلم‌های برتر با مقادیر پیش‌بینی متقارن‌تر و مثبت‌تر نسبت به نسخه اولیه میباشند.
	
	مقادیر کوچک و منفی در نسخه اولیه حذف شده‌اند.
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (862).png}	\\[1cm]
	\end{center}
	
	6.تحلیل \lr{RMSE} بر اساس ژانر : 
	
	کاهش چشمگیر \lr{RMSE} نسبت به نسخه اولیه به طوری که نسخه اولیه تقریبا 17.2-20.2 بود اما نسخه بهبودیافته تقریبا 75.1-77.1 میباشد.
	
	نشان می‌دهد نرمال‌سازی و افزایش \lr{k} باعث پیش‌بینی دقیق‌تر شده است.
	
	7.همینطور 4 فایل خروجی داریم که به شرح زیر میباشند: 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (864).png}	\\[0.5cm]
	\end{center} 
	
	\lr{recommendations\_full.csv} شامل پیش‌بینی‌های کامل برای تمام کاربران (اما     چاپ‌شده فقط برای کاربر 1).
	
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (865).png}	\\[0.5cm]
	\end{center} 
	
	\lr{recommendations\_test.csv} نتایج پس از حذف 20\% داده، مجدداً برای کاربر ۱ ذخیره شده است.
	
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (866).png}	\\[0.5cm]
	\end{center} 
	
	\lr{errors\_sample.csv} شامل چند ردیف از مقایسه‌ی واقعی و پیش‌بینی برای تحلیل خطا می باشد.
	
	
	و در نهایت یک تصویر که شامل دو نمودار است را هم تولید میکند که در بخش بعد توضیح خواهیم داد . 
	\newpage
	
	
	% --------------------تحلیل نمودار ها --------------------
	\newsection{تحلیل نمودار ها }
	
	همانطور که در بخش قبل اشاره کردیم ، در خروجی کد بهبودیافته دو نمودار هم داریم که در این بخش آن ها را توضیح خواهیم داد . 
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (859).png}	\\[0.5cm]
	\end{center} 
	
	
	این نمودار توزیع خطاها \lr{(Predicted – True)} را نشان می‌دهد ، در این نمودار خطاها حول مقدار 4- متمرکز هستند .
	
	پیک اصلی توزیع دقیقاً روی بازه‌ی 4- قرار گرفته، یعنی:
	مدل به‌طور سیستماتیک مقدار خروجی را حدود ۴ واحد کمتر از مقدار واقعی پیش‌بینی می‌کند.
	
	یک \lr{Bias} (سوگیری) منفی وجود دارد.
	
	نکات مربوط به این نمودار : 
	
	1.بیشترین تراکم بین 3- و 5- است : 
	
	به این معنی که بخش عمده داده‌ها دارای خطای تقریباً ثابت هستند و مدل در اکثر موارد در همین محدوده پیش‌بینی اشتباه انجام داده است .
	این پدیده معمولاً وقتی دیده می‌شود که:
	
	الف)مدل \lr{underfitting} باشد.
	
	ب)مدل یک میانگین ثابت تولید کند.
	
	ج)داده‌ها پراکندگی بالا داشته باشند.
	
	د) \lr{loss function} باعث ایجاد یک مقدار ثابت شود.
	
	
	2.در این نمودار یک قله داریم : 
	
	چون مدل بیشتر خطاها را روی یک مقدار نسبتاً ثابت انجام می‌دهد.
	
	یعنی مدل قدرت تفکیک یا \lr{generalization} کافی ندارد و خطاهایش به صورت تصادفی پخش نشده‌اند ، بلکه روی یک مقدار تکرار می‌شوند.
	
	3.در بعضی بخش ها تراکم کمتر است : 
	
	این مورد میتواند دو دلیل داشته باشد اول اینکه داده‌های واقعی در آن نقاط کم هستند و دوم اینکه مدل رفتار متفاوتی در شرایط نادر دارد . 
	
	بنابراین دم‌های دو طرف به خاطر موارد \lr{outlier} شکل گرفته‌اند.\\[1cm]
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (867).png}	\\[1cm]
	\end{center} 
	
	این نمودار پراکندگی \lr{RMSE} برحسب تعداد داده‌ها را نشان میدهد ، به طوریکه : 
	
	محور افقی نشان دهنده تعداد داده‌های هر کاربر میباشد و محور عمودی مقدار خطای \lr{RMSE} را نشان میدهد . \newpage
	
	نکات مربوط به این نمودار :  
	
	1.هر چه داده بیشتر باشد آنگاه \lr{RMSE} نیز  بیشتر خواهد بود :
	
	الف) جرا که وقتی کاربران داده زیاد داشته باشند ، تنوع داده بیشتر خواهد بود.
	
	ب) وقتی داده کم است یعنی مدل میانگین سازی میکند آنگاه  \lr{RMSE} پایین خواهد بود. 
	
	ج) وقتی داده زیاد باشذ آنگاه رفتار پیچیده تر و خطا بیشتر خواهد بود ، به عنوان مثال کاربرانی که 1000+ آیتم دارند ، احتمالاً سلیقه متنوع و رفتار غیرخطی دارند و مدل به آسانی نمی‌تواند همه الگوها را بگیرد.
	
	2.در نقاطی که \lr{RMSE}  بین 5.2 تا 4 و همینطور تعداد داده ها بین 0 تا 300 میباشند ، تراکم شدید داریم : 
	
	الف) اغلب کاربران داده کم دارند. (واقعیت مجموعه‌های \lr{rating})
	
	ب) تعداد زیاد نمونه را داریم که باعث میشود نقاط روی هم می‌افتند.
	
	ج) مدل در این ناحیه ضعیف است.
	
	این منطقه یک ابر پرتراکم تشکیل داده است.
	
	3.نقاطی که دیتای 1000+ دارند پراکنده اند چرا که : 
	
	الف) تعداد کاربران پرتعداد کم است .
	
	ب) رفتار پیش‌بینی مدل روی این گروه قابل اعتماد نیست ، زیرا مدل احتمالاً روی این افراد \lr{overfit} نشده و مشکل دارد.
	
	
	\newpage
	
	
	% --------------------مقایسه نتایج دو نسخه --------------------
	\newsection{مقایسه نتایج دو نسخه }
	
	\renewcommand{\arraystretch}{2} % مقدار 2 را قرار میدهیم
	\begin{table}[h!]
		\centering
		\begin{tabular}{|p{5cm}|p{4cm}|p{5cm}|}
			\hline
			\textbf{ویژگی} & \textbf{نسخه اولیه} & \textbf{نسخه بهینه‌شده} \\ \hline
			
			\lr{Bias} خطا & خطای ثابت حدود 4- & خطا حول صفر پخش شد \\ \hline
			
			پراکندگی خطاها & خطاها در یک نقطه جمع شده‌اند & توزیع طبیعی و بدون قله غیرطبیعی \\ \hline
			
			رفتار با افزایش داده & \lr{RMSE} افزایش شدید داشت & شیب کاهش یافت یا پایدار شد \\ \hline
			
			توانایی یادگیری الگوهای پیچیده & \lr{Underfitting} شدید & یادگیری بهتر با کمک همسایه‌ها و نرمال‌سازی \\ \hline
			
			قدرت شخصی‌سازی \lr{(K neighbors)} & صفر(مدل کور) & مدل تفاوت هر نمونه/کاربر را در نظر می‌گیرد \\ \hline
			
			پایداری آموزش & ناپایدار و تک‌الگویی & پایدار، بدون افت شدید \\ \hline
			
			کیفیت خروجی & خام و بسیار خطادار & پیش‌بینی نزدیک‌تر به مقادیر واقعی \\ \hline
			
		\end{tabular}
		\caption{مقایسه نسخه اولیه و نسخه بهینه‌شده سیستم توصیه‌گر مبتنی بر \lr{SVD}}
	\end{table}
	
	\newpage
	
	
	% -------------------- پاسخ به سوالات کلیدی --------------------
	\newsection{پاسخ به سوالات کلیدی }
	
	\textbf{1.وقتی 20\% را حذف کردیم، در درایه‌ها 0 گذاشتیم یا \lr{NaN}؟ چرا؟}
	
	
	ما در هر دو نسخه از کد ، وقتی داده آموزشی ساخته میشود از خط زیر استفاده کردیم : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (868).png}	\\[0.5cm]
	\end{center} 
	
	یعنی درایه‌هایی که در داده‌ی \lr{train} وجود ندارند با 0 پر می‌شوند (نه \lr{NaN}) ، دلیل اینکه از صفر استفاده کردیم ، این است که در روش \lr{SVD}مقدار 0 به‌عنوان عدم مشاهده تفسیر می‌شود، نه امتیاز واقعی صفر ، بنابراین صفرشدن این خانه‌ها باعث بایاس عددی شدید نمی‌شود، به‌شرط اینکه نرمال‌سازی انجام شده باشد.
	
	چرا که در نرمال سازی : 
	
	الف) مقدار صفر تبدیل میشود به 0- .
	
	ب) مدل دیگر 0 را به‌عنوان امتیاز واقعی نمی‌بیند .
	
	ج) بلکه آن را بخشی از ماتریس نرمال‌سازی‌شده تلقی می‌کند. 
	
	د) پس اثر منفی صفر کاملاً خنثی می‌شود. 
	
	
	\textbf{2.کدام کاربران پیشنهادهای درست‌تر گرفتند؟ آیا هرچه خطای سیستم کمتر شد کارکرد بهتر شد؟} 
	
	الف) چه کسانی عملکرد بهتری گرفتند؟
	
	کاربران با تعداد امتیاز \lr{(activity)} بالاتر معمولاً مدل را بهتر آموزش می‌دهند چون اطلاعات بیشتری از سلیقه آن‌ها وجود دارد - بنابراین اغلب پیش‌بینی‌های منطبق‌تر و با واریانس کمتر برایشان تولید می‌شود.
	
	اما در نسخه‌ی خیلی ساده (بدون نرمال‌سازی) ممکن بود عکس این اتفاق بیفتد (کاربران پر‌داده \lr{RMSE} بیشتر نشان دهند) چون مدل \lr{underfit} یا سوگیری داشت. در نسخه‌ی بهبودیافته با \lr{mean-centering}و \lr{k} بزرگ‌تر، معمولاً \lr{trend} به سمت کارایی بهتر برای کاربران پر‌اطلاعات برمی‌گردد.
	
	کاربران با امتیازهای پراکنده یا نامنظم (رفتار پیچیده) احتمالاً هنوز خطای بیشتری دارند؛ یعنی بیشتر امتیاز دادن لزوماً همیشه بهترین نشانه نیست مگر اینکه امتیازها سازگار و نماینده‌ی سلیقه باشند.
	
	ژانرها: ما در خروجیِ نسخه بهبود یافته دیدیم که \lr{RMSE} ژانرها کاهش یافته است این یعنی پیش‌بینی برای اکثر ژانرها بهتر شده و به طور کلی مدل عمومی‌تر شده است.
	
	
	ب) آیا هرچه خطای سیستم کمتر شد ، کارکرد هم بهتر شد؟
	
	بله ، اگر معیار ما همان "چقدر پیش بینی عددی نزدیک به مقدار واقعی است" باشد ، کاهش \lr{RMSE/MAE} به طور مستقیم نشان دهنده افزایش دقت عددی مدل است. 
	
	اما نکات مهم:
	
	برای سیستم پیشنهاد‌دهی گاهی معیارهای \lr{ranking} مهم‌تر از \lr{RMSE} هستند. ممکن است \lr{RMSE} کاهش یابد ولی ترتیبِ بهترین آیتم‌ها تغییر نکند یا بالعکس.
	
	\textbf{3.چرا بعد از نرمال‌سازی \lr{RMSE/MAE} بزرگ‌تر شد؟}
	
	نرمال‌سازی باعث می‌شود امتیازها از بازه اصلی (۱ تا ۵) خارج شوند و حول صفر قرار بگیرند. چون \lr{RMSE} و \lr{MAE} همیشه در واحد داده‌ای که روی آن محاسبه می‌شوند سنجیده می‌شوند، وقتی دامنه داده‌ها تغییر می‌کند دامنه خطا نیز تغییر می‌کند. بنابراین بزرگ‌تر دیده شدن \lr{RMSE} بعد از نرمال‌سازی طبیعی است و نشان‌دهنده افزایش خطا نیست ، بلکه فقط به خاطر تغییر مقیاس داده‌هاست. برای مقایسه صحیح باید \lr{RMSE} را بعد از بازگرداندن پیش‌بینی‌ها به مقیاس اصلی محاسبه کرد.
	
	برای اینکار تغییرات زیر را در کد اعمال کردیم : 
	
	الف) جایگزین کل قسمت نرمال‌سازی و ساخت \lr{sparse matrix} با این بخش:
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (869).png}	\\[1cm]
	\end{center} 
	
	
	ب) تابع \lr{SVD} اصلاح‌شده : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (870).png}	\\[1cm]
	\end{center} 
	
	ج) بخش \lr{Train/Test} را هم اصلاح کردیم : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (871).png}	\\[1cm]
	\end{center} 
	
	با این نسخه به اهداف زیر رسیدیم و خطاها را کاهش دادیم : 
	
	1.نرمال‌سازی بهتر انجام می‌شود
	
	2.مقادیر پیش‌فرض مناسب‌تر برای \lr{cold-start} گذاشته می‌شود
	
	3.\lr{k} مناسب‌تر و \lr{SVD} پایدارتر استفاده می‌شود
	
	4.به جای مقادیر گمشده ، میانگین کاربر را قرار دادیم.(به جای 0)
	
	5. \lr{RMSE} و \lr{MAE} به طور محسوسی پایین‌تر می‌آیند : 
	
	\begin{center}
		\includegraphics[width=0.75\linewidth]{Screenshot (872).png}	\\[0.5cm]
	\end{center} 
	
	همانطور که در تصویر هم مشخص است مقادیر \lr{RMSE} و \lr{MAE} به ترتیب به 9412.0 و 7293.0 کاهش پیدا کرده اند.
	
	\newpage
	
	
	% -------------------- جمع بندی --------------------
	\newsection{جمع بندی }
	تحلیل نتایج نشان داد که: 
	
	1.نرمال‌سازی داده‌ها باعث بهبود پیش‌بینی‌ها شد و \lr{RMSE} کاهش یافت. 
	
	2.افزایش تعداد مؤلفه‌های \lr{SVD (k=100) } نسبت به نسخه بدون نرمال‌سازی و \lr{k=50 }دقت سیستم را افزایش داد.
	
	3.کاربران با فعالیت بیشتر (تعداد امتیاز بالاتر) معمولاً پیشنهادات دقیق‌تری دریافت کردند.
	
	4.دقت سیستم بسته به ژانر فیلم‌ها متفاوت بود؛ برخی ژانرها مانند \lr{Comedy} و \lr{Drama} با تعداد داده کافی، پیش‌بینی دقیق‌تری داشتند.
	
	5.حذف 20\% از داده‌ها و اجرای مجدد سیستم نشان داد که سیستم قادر به تخمین معقول امتیازات فیلم‌های حذف شده است و میانگین خطا در سطح قابل قبول باقی ماند.
	
	\newpage
	
	
	% -------------------- نتیجه‌گیری --------------------
	\newsection{ نتیجه‌گیری}
	
	در این پروژه با هدف درک عمیق مفاهیم نهفته در سیستم‌های توصیه‌گر، از روش تجزیه مقدار منفرد \lr{SVD} در تحلیل ماتریس داده‌های کاربران و فیلم‌ها استفاده شد. در ابتدا داده‌های مربوط به امتیازدهی کاربران به فیلم‌ها به صورت یک ماتریس کاربر-آیتم تعریف شدند. برای ارزیابی عملکرد سیستم و سنجش توانایی مدل در پیش‌بینی امتیازات، بخشی از داده‌ها ( 20\% از کل داده‌ها) به صورت تصادفی حذف شد تا به عنوان داده‌های آزمایشی مورد استفاده قرار گیرد. سپس الگوریتم با استفاده از 80\% داده‌های باقی‌مانده آموزش دید تا بتواند الگوهای پنهان در رفتار کاربران را بیاموزد و امتیازات حذف‌شده را بازسازی کند.
	
	یکی از نکات کلیدی در این تحلیل این بود که مدل، اگرچه در خروجی تنها پیشنهادات مربوط به کاربر ۱ را نشان می‌دهد، اما در واقع برای تمام کاربران محاسبات مربوط به پیش‌بینی امتیاز و استخراج پیشنهادات را انجام می‌دهد. نمایش خروجی تنها برای یک کاربر، صرفاً به منظور نمونه‌سازی و وضوح نتایج است و به معنای محدود بودن عملکرد مدل به یک کاربر خاص نیست. بنابراین، مدل قابلیت گسترش برای تمامی کاربران سیستم را دارد.
	
	در مورد حذف 20\% داده‌ها نیز باید گفت که این حذف، تنها جهت ایجاد مجموعه آزمون صورت می‌گیرد و در ادامه تمام مراحل مدل‌سازی، آموزش و بازسازی ماتریس بر اساس 80\%  داده‌های باقی‌مانده انجام می‌شود. در نهایت، با مقایسه‌ی امتیازات واقعی و پیش‌بینی‌شده برای بخش حذف‌شده، می‌توان دقت مدل را از طریق معیارهایی نظیر \lr{RMSE} یا \lr{MAE} اندازه‌گیری کرد.
	
	در مجموع، نتایج نشان دادند که روش \lr{SVD} روشی مؤثر برای کاهش بُعد، حذف نویز و کشف الگوهای پنهان در داده‌های کاربران است. این روش به ما اجازه داد بدون نیاز به تحلیل مستقیم کل داده‌های بزرگ و پراکنده، ساختاری فشرده و قابل تحلیل از روابط کاربران و آیتم‌ها به دست آوریم. چنین مدلی می‌تواند پایه‌ای قوی برای توسعه‌ی سیستم‌های پیشنهاددهنده هوشمندتر در حوزه‌های مختلف از جمله فیلم، موسیقی، کتاب و خرید آنلاین باشد.
	
	در نهایت، اجرای موفق این پروژه نشان داد که با بهره‌گیری از الگوریتم‌های خطی نظیر \lr{SVD} و مفاهیم ریاضی ماتریسی، می‌توان بین داده‌های خام و تصمیمات هوشمندانه پلی مؤثر ایجاد کرد. این تجربه همچنین اهمیت انتخاب داده‌های آموزشی مناسب، تقسیم منطقی داده‌ها برای آموزش و آزمون، و تفسیر دقیق نتایج را به‌خوبی برجسته می‌کند.
	
	\newpage
	
	
	% -------------------- فهرست منابع --------------------
	\newsection{ فهرست منابع}
	\begin{sources}
		
		\item
		\href{https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset}
		{\nolinkurl{https://www.kaggle.com/datasets/rounakbanik/the-movies-dataset}}
		
		\item
		\href{https://www.geeksforgeeks.org/machine-learning/singular-value-decomposition-svd/}
		{\nolinkurl{https://www.geeksforgeeks.org/machine-learning/singular-value-decomposition-svd/}}
		
		\item
		\href{https://math.mit.edu/classes/18.095/2016IAP/lec2/SVD_Notes.pdf}
		{\nolinkurl{https://math.mit.edu/classes/18.095/2016IAP/lec2/SVD_Notes.pdf}}
		
	\end{sources}
	
	
\end{document}
